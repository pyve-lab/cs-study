# 페이징을 통한 가상 메모리 관리

## 1. 연속 메모리 할당의 한계

연속 메모리 할당 방식에는 **두 가지 근본적인 문제**가 있다.

### 1-1. 외부 단편화

- 프로세스의 실행과 종료가 반복되며
- 메모리 사이사이에 **작은 빈 공간**이 생김
- 총 빈 공간은 충분해도
    - 연속되지 않아 프로세스 적재 불가

---

### 1-2. 물리 메모리보다 큰 프로세스 실행 불가

- 프로세스 크기 > 사용자 영역 크기
- 연속 메모리 할당 방식으로는 **실행 자체가 불가능**

👉 이 두 문제를 해결하기 위해 등장한 것이

**가상 메모리**

---

## 2. 가상 메모리(Virtual Memory)

### 2-1. 가상 메모리란?

- 실행하고자 하는 프로그램을
    - **일부만 메모리에 적재**
- 실제 물리 메모리보다
    - **더 큰 프로세스를 실행할 수 있게 하는 기술**

---

### 2-2. 가상 메모리 관리 기법

- **페이징(Paging)**
- **세그멘테이션(Segmentation)**

👉 이 장에서는 **페이징**을 중점적으로 다룸

---

## 3. 페이징(Paging)

### 3-1. 페이징이란?

- 프로세스의 **논리 주소 공간**을
    - 일정한 크기의 **페이지(Page)** 로 나눔
- 메모리의 **물리 주소 공간**을
    - 페이지와 같은 크기의 **프레임(Frame)** 으로 나눔
- 페이지를 프레임에 **불연속적으로 할당**

👉 **페이지 크기 = 프레임 크기**

---

### 3-2. 페이징의 핵심 아이디어

- 외부 단편화의 원인:
    - 서로 다른 크기의 프로세스를
    - 연속적으로 할당했기 때문
- 해결 방법:
    - 모든 메모리 단위를 **같은 크기**로 쪼개기
    - 불연속 배치 허용

👉 **외부 단편화 해결**

---

## 4. 페이징에서의 스와핑

### 4-1. 페이지 단위 스와핑

- 기존 스와핑:
    - **프로세스 단위**
- 페이징에서는:
    - **페이지 단위**

---

### 4-2. 페이지 인 / 페이지 아웃

- **페이지 아웃(Page-out)**
    - 당장 필요 없는 페이지를
    - 보조기억장치로 이동
- **페이지 인(Page-in)**
    - 실행에 필요한 페이지를
    - 메모리로 적재

---

### 4-3. 페이징 스와핑의 의미

- 프로세스를 실행하기 위해
    - **모든 페이지가 메모리에 있을 필요 없음**
- 필요한 페이지만 메모리에 적재

👉 물리 메모리보다 **큰 프로세스 실행 가능**

---

## 5. 페이지 테이블(Page Table)

### 5-1. 페이지 테이블이 필요한 이유

- 페이징에서는
    - 프로세스가 메모리에 **불연속적으로 배치**
- CPU 입장에서:
    - 다음 명령어 위치를 찾기 어려움

👉 이를 해결하기 위한 장치가 **페이지 테이블**

---

### 5-2. 페이지 테이블이란?

- **페이지 번호 ↔ 프레임 번호**를 짝지어 주는 표
- 프로세스마다 **자신만의 페이지 테이블**을 가짐

👉 물리적으로는 흩어져 있어도

👉 **논리 주소는 연속적으로 보이게 함**

---

### 5-3. CPU 관점에서의 장점

- CPU는
    - 논리 주소를 순차적으로 실행
- 실제 물리 위치는
    - 페이지 테이블이 해결

---

## 6. 내부 단편화(Internal Fragmentation)

### 6-1. 내부 단편화란?

- 페이지의 크기보다
    - 프로세스의 마지막 부분이 작은 경우
- 페이지 내부에
    - 사용되지 않는 공간 발생

---

### 6-2. 내부 단편화 예시

- 페이지 크기: **10KB**
- 프로세스 크기: **108KB**

→ 마지막 페이지에서 **2KB 낭비**

---

### 6-3. 내부 단편화 특징

- 메모리 낭비 발생
- 하지만:
    - 외부 단편화보다
    - 낭비 크기가 작은 경우가 많음

---

## 7. 페이지 크기와 대형 페이지

- 기본적으로:
    - 모든 페이지 크기는 동일
- 예외:
    - **대형 페이지(Huge Page)** 허용 가능
    - 기본 페이지보다 큰 크기의 페이지 사용

---

## 8. PTBR (Page Table Base Register)

### 8-1. PTBR이란?

- CPU 내부의 특별한 레지스터
- **현재 프로세스의 페이지 테이블 위치**를 가리킴

---

### 8-2. PTBR의 역할

- 프로세스마다 페이지 테이블이 다르기 때문에
- CPU는
    - PTBR을 통해
    - 해당 프로세스의 페이지 테이블을 참조

---

## 9. 페이지 테이블의 문제점

### 메모리 접근 횟수 증가

- 페이지 테이블이 메모리에 있다면:
    1. 페이지 테이블 접근
    2. 실제 페이지 접근

👉 **메모리 접근 2번 필요**

- 메모리 접근은
    - 레지스터 / 캐시보다 느림
- 성능 저하 발생

---

## 10. TLB (Translation Lookaside Buffer)

### 10-1. TLB란?

- CPU 곁에 위치한
    - **페이지 테이블 캐시**
- 페이지 테이블 일부를 저장

---

### 10-2. TLB 히트 / 미스

- **TLB 히트**
    - 논리 주소 정보가 TLB에 있음
    - → 메모리 접근 **1번**
- **TLB 미스**
    - TLB에 없음
    - → 메모리 접근 **2번**

👉 불필요한 메모리 접근 감소

---

## 11. 페이징에서의 주소 변환

### 11-1. 주소 변환에 필요한 정보

- 어떤 페이지(프레임)인지
- 페이지(프레임) 내부에서의 위치

---

### 11-2. 논리 주소 구조

- **페이지 번호(Page Number)**
- **변위(Offset)**

👉 논리 주소 = ⟨페이지 번호, 변위⟩

---

### 11-3. 주소 변환 과정

1. 페이지 번호로 페이지 테이블 조회
2. 프레임 번호 확인
3. ⟨프레임 번호, 변위⟩ 생성
4. 물리 주소 접근

👉 변위 값은 **논리/물리 주소에서 동일**

---

## 12. 페이지 테이블 엔트리 (PTE)

### 12-1. PTE란?

- 페이지 테이블의 **각 행**
- 페이지 하나에 대한 정보 저장

---

### 12-2. 기본 구성

- 페이지 번호
- 프레임 번호

---

### 12-3. 추가로 담기는 정보

### ① 유효 비트 (Valid Bit)

- 페이지가 메모리에 있는지 여부
- `0` : 메모리에 없음 (스왑 영역)
- `1` : 메모리에 있음

---

### ② 페이지 폴트(Page Fault)

- 유효 비트가 `0`인 페이지에 접근 시 발생
- 하드웨어 인터럽트로 처리

### 처리 과정

1. CPU 작업 내용 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지를 메모리로 적재
4. 유효 비트 `1`로 변경
5. CPU 실행 재개

---

### ③ 보호 비트 (Protection Bit)

- 페이지 접근 권한 제어

| 권한 | R W X |
| --- | --- |
| 읽기 전용 | 1 0 0 |
| 쓰기 전용 | 0 1 0 |
| 읽기/실행 | 1 0 1 |
| 읽기/쓰기/실행 | 1 1 1 |

---

### ④ 참조 비트 (Reference Bit)

- CPU가 페이지에 접근한 적 있는지
- 접근함: `1`
- 접근 안 함: `0`

---

### ⑤ 수정 비트 (Dirty Bit)

- 페이지 내용이 수정되었는지 여부
- 수정됨: `1`
- 수정 안 됨: `0`

👉 페이지 아웃 시:

- 수정 비트 `1` → 보조기억장치에 쓰기 필요
- 수정 비트 `0` → 쓰기 불필요

---

## 핵심 요약

- 페이징은 가상 메모리의 핵심 기법
- 외부 단편화 해결
- 물리 메모리보다 큰 프로세스 실행 가능
- 페이지 테이블로 논리 주소 연속성 유지
- 내부 단편화 발생 가능
- TLB로 성능 개선
- 페이지 폴트로 필요한 페이지만 적재

---

## 한 줄 정리

> ❝ 페이징은
> 
> 
> 메모리를 일정한 크기로 나누어
> 
> 효율과 유연성을 동시에 확보하는 가상 메모리 기법이다 ❞
>