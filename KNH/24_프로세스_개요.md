# 프로세스(Process) 개요

## 1. 프로세스란?

- **실행 중인 프로그램 = 프로세스**
- 프로그램은 실행 전까지 **보조기억장치(SSD/HDD)에 저장된 데이터 덩어리**
- 더블 클릭 등으로 실행되어 **메모리에 적재되고 CPU에 의해 실행되는 순간**, 프로그램은 **프로세스**가 된다.
- 이 과정을 **프로세스 생성(Process Creation)** 이라고 한다.

---

## 2. 프로세스의 종류

프로세스는 실행 형태에 따라 크게 두 가지로 나뉜다.

### 2-1. 포그라운드 프로세스 (Foreground Process)

- 사용자가 **직접 보고 상호작용**할 수 있는 프로세스
- 예시
    - 웹 브라우저
    - 메모장
    - 게임
    - IDE (IntelliJ, VS Code 등)

---

### 2-2. 백그라운드 프로세스 (Background Process)

- 사용자가 **직접 볼 수 없는 공간**에서 실행되는 프로세스

백그라운드 프로세스는 다시 두 가지로 나뉜다.

### (1) 사용자와 상호작용하는 백그라운드 프로세스

- 화면에는 보이지 않지만 알림, 네트워크 요청 등으로 간접적으로 상호작용
- 예: 메신저 알림 처리, 업데이트 체크

### (2) 사용자와 상호작용하지 않는 백그라운드 프로세스

- **데몬(Daemon)** 또는 **서비스(Service)** 라고 부름

### ✅ 데몬(Daemon)과 서비스(Service) 정리

- **공통점**
    - 둘 다 사용자와 직접 상호작용하지 않음
    - 백그라운드에서 **항상 실행되며 특정 기능을 제공**
    - 시스템이 켜질 때 함께 실행되는 경우가 많음
- **데몬(Daemon)**
    - 주로 **유닉스/리눅스 계열 운영체제**에서 사용하는 용어
    - 예시
        - `sshd` : 원격 접속 처리
        - `cron` : 정기 작업 수행
- **서비스(Service)**
    - 주로 **Windows 계열 운영체제**에서 사용하는 용어
    - 예시
        - Windows Update Service
        - 백신 서비스

> 즉, 운영체제와 용어만 다를 뿐 역할은 거의 동일하다고 이해하면 된다.
> 

---

## 3. 프로세스와 CPU 사용

- 모든 프로세스는 **CPU를 사용해야 실행**될 수 있다.
- 하지만 CPU 자원은 **한정적**이므로,
    - 여러 프로세스가 **번갈아 가며 CPU를 사용**한다.
    - 각 프로세스는 **정해진 시간만큼만 CPU를 할당**받는다.

### 💡 이 설명이 RR 스케줄링인가?

👉 **맞다. 영상 기준으로 보면 이 설명은 `라운드 로빈(Round Robin, RR)` 스케줄링을 염두에 둔 설명이다.**

- RR 스케줄링 특징
    - 모든 프로세스에게 **동일한 CPU 시간(Time Quantum)** 을 부여
    - 시간이 끝나면 **강제로 다음 프로세스로 전환**

---

## 4. 타이머 인터럽트 (Timer Interrupt)

- CPU에 클럭 신호를 발생시키는 장치에 의해 **주기적으로 발생하는 하드웨어 인터럽트**
- 역할
    - **“네 시간 끝났어, 다음 프로세스로 넘어가”** 라고 운영체제에 알림
- 이 인터럽트가 발생하면
    - 현재 실행 중인 프로세스는 CPU 사용을 멈추고
    - 다음 프로세스에게 CPU 사용 권한을 넘긴다

---

## 5. 프로세스 제어 블록 (PCB, Process Control Block)

CPU를 번갈아 사용하는 프로세스들을 관리하기 위해

운영체제는 **PCB(Process Control Block)** 라는 자료구조를 사용한다.

### 5-1. PCB란?

- 프로세스 하나당 하나씩 존재하는 **프로세스 관리용 정보 묶음**
- 태그나 신분증 같은 역할
- **커널 영역(Kernel Space)** 에 저장됨
- 프로세스 생성 시 함께 생성되고, 종료 시 폐기됨

운영체제는 **PCB를 보고 프로세스를 관리**한다.

---

### 5-2. PCB에 담기는 대표적인 정보

> (실제 구성은 운영체제마다 다름)
> 

### ① 프로세스 ID (PID)

- 프로세스를 식별하는 고유 번호
- 예시
    - 학교의 학번
    - 회사의 사번
- 실제 사례
    - IntelliJ를 종료했는데 `localhost:7070 이미 사용 중` 오류 발생
    - → 7070 포트를 사용 중인 **프로세스를 PID로 찾아 종료**

---

### ② 레지스터 값

- CPU 사용이 끝나고 차례를 넘길 때,
    - **현재까지 사용한 레지스터 값**을 저장해야 함
- 이유
    - 다음 차례에 실행할 **명령어 주소**
    - 연산 중간 결과를 기억해야 함
- 이 정보가 없으면
    - 이전 실행 지점부터 이어서 실행할 수 없음

---

### ③ 프로세스 상태

- 생성(New)
- 준비(Ready)
- 실행(Running)
- 대기(Waiting)
- 종료(Terminated)

---

### ④ CPU 스케줄링 정보

- 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보

---

### ⑤ 메모리 정보

- 프로세스가 **메모리의 어느 위치에 적재되어 있는지**
- **페이지 테이블(Page Table)** 정보 포함

### 💡 여기서 말하는 페이지는 페이징의 그 페이지인가?

👉 **맞다.**

- 이는 **페이징 기법에서 사용하는 페이지(Page)** 를 의미
- PCB에는
    - “이 프로세스의 가상 주소가 실제 메모리 어디에 있는지”
    - 를 알 수 있는 **페이지 테이블 위치 정보**가 저장된다

---

### ⑥ 사용한 파일 및 입출력 장치 정보

- 열려 있는 파일
- 사용 중인 입출력 장치 정보

---

## 6. 문맥 교환 (Context Switch)

### 6-1. 문맥(Context)이란?

- 프로세스가 실행을 재개하기 위해 필요한 **모든 중간 상태 정보**
- 예시
    - 레지스터 값
    - 프로그램 카운터
    - 스택 상태 등

---

### 6-2. 문맥 교환 과정

1. 현재 실행 중인 프로세스의 **문맥을 백업**
2. 다음 실행할 프로세스의 **문맥을 복구**
3. 실행 중인 프로세스가 자연스럽게 교체됨

이 과정을 **문맥 교환(Context Switching)** 이라고 한다.

- 문맥은 **PCB에 저장**
- 이 덕분에
    - 여러 프로세스가 **끊임없이 빠르게 번갈아 실행**되는 것처럼 보인다

---

## 7. 프로세스의 메모리 구조 (사용자 영역)

프로세스는 사용자 영역(User Space)에 다음과 같은 구조로 저장된다.

```
┌───────────────┐  높은 주소
│   스택(Stack) │  ↓
├───────────────┤
│    힙(Heap)   │  ↑
├───────────────┤
│ 데이터(Data)  │
├───────────────┤
│ 코드(Code)    │
└───────────────┘  낮은 주소

```

---

### 7-1. 코드 영역 (텍스트 영역)

- CPU가 실행할 **기계어 명령어** 저장
- 특징
    - 읽기 전용(Read-only)
    - 쓰기 금지
- 이유
    - 실행 중 코드가 변조되면 안 되기 때문

---

### 7-2. 데이터 영역

- 프로그램 실행 동안 **유지되어야 할 데이터**
- 대표 예
    - 전역 변수
    - 정적 변수

---

### 7-3. 힙 영역 (Heap)

- 프로그래머가 **직접 할당/해제**하는 메모리 공간
- 예시
    - `new`, `malloc`
- 반드시 **반환해야 함**
    - 반환하지 않으면 → **메모리 누수(Memory Leak)** 발생

---

### 7-4. 스택 영역 (Stack)

- **일시적인 데이터** 저장 공간
- 대표 예
    - 지역 변수
    - 매개변수
    - 함수 호출 정보
- 동작 방식
    - 필요할 때 `push`
    - 사용이 끝나면 `pop`

---

### 7-5. 정적 할당 영역 vs 동적 할당 영역

| 구분 | 영역 |
| --- | --- |
| 정적 할당 영역 | 코드 영역, 데이터 영역 |
| 동적 할당 영역 | 힙 영역, 스택 영역 |
- 힙: **낮은 주소 → 높은 주소**
- 스택: **높은 주소 → 낮은 주소**

👉 이렇게 배치하면

힙과 스택이 커지더라도 **서로 충돌하지 않음**

---

## 핵심 요약

- 프로세스 = 실행 중인 프로그램
- PCB는 프로세스의 모든 상태를 관리하는 핵심 자료구조
- 문맥 교환 덕분에 멀티태스킹이 가능
- 메모리 구조는 **코드 / 데이터 / 힙 / 스택**
- RR 스케줄링 + 타이머 인터럽트가 CPU 분할 사용의 핵심