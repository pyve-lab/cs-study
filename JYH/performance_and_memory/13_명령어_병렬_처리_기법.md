# 명령어 병렬 처리 기법

CPU가 시간을 낭비하지 않고 알뜰하게 잘 쓰면서 명령어를 빠르게 처리하는지를 확인할 수 있습니다.
(파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리)

---

## 1. 명령어 파이프라인 (Instruction Pipeline)
하나의 명령어가 처리되는 과정을 여러 단계로 나누어, 각 단계를 동시에 겹쳐서 실행하는 기법입니다.

### 1) 명령어 처리의 4단계 (일반적인 구분)
1. **인출 (Fetch)**: 메모리로부터 명령어를 가져옴
2. **해석 (Decode)**: 가져온 명령어를 해석함
3. **실행 (Execute)**: 해석한 명령어를 실행함
4. **저장 (Write Back)**: 결과를 메모리에 저장함
> *참고: 전공서에 따라 2단계, 5단계 등으로 나누기도 하지만 핵심은 '단계를 나눈다'는 것임.*

### 2) 파이프라이닝의 원리
* 각 단계가 겹치지만 않는다면 CPU는 여러 단계를 동시에 수행할 수 있습니다.
* 마치 공장의 **컨베이어 벨트**와 같은 방식으로, 앞의 명령어가 해석될 때 뒤의 명령어를 인출합니다.



### 3) 파이프라인 위험 (Pipeline Hazard)
파이프라이닝이 예상대로 성능 향상을 이루지 못하고 중단되는 상황입니다.

| 종류 | 원인 | 상세 설명 |
| :--- | :--- | :--- |
| **데이터 위험** | 명령어 간 의존성 | 이전 명령어의 결과값이 다음 명령어의 입력값일 때, 앞의 작업이 끝날 때까지 기다려야 함 |
| **제어 위험** | 프로그램카운터의 갑작스러운 변화 | `JUMP`, `CALL` `INTERRUPT`등으로 실행 흐름이 바뀌면, 이미 인출해둔 다음 명령어들이 무용지물이 됨 (해결책: **분기 예측**) |
| **구조적 위험** | 자원 충돌 | 서로 다른 명령어가 동시에 같은 CPU 부품(ALU, 레지스터 등)을 사용하려 할 때 발생 |

---

## 2. 슈퍼스칼라 (Super Scalar)
CPU 내부에 **명령어 파이프라인을 여러 개** 두는 설계 방식입니다.

* **특징**: 한 번에 여러 명령어를 인출하고 실행할 수 있는 구조입니다.
* **현대 CPU**: 오늘날 대부분의 CPU는 멀티코어/멀티스레드와 함께 슈퍼스칼라 구조를 사용합니다.
* **성능**: 이론적으로는 파이프라인 개수에 비례해 빨라지지만, 개수가 많아질수록 **파이프라인 위험도 증가**하므로 관리가 매우 복잡합니다.



---

## 3. 비순차적 명령어 처리 (OoOE, Out-of-Order Execution)
파이프라인의 중단을 막기 위해 명령어를 **순서대로 처리하지 않고 실행**하는 기법입니다.

### 1) 핵심 아이디어
* 순차적으로만 실행하면 의존성이 있는 명령어 때문에 파이프라인 전체가 멈추게 됩니다.
* 이때 **결과에 지장을 주지 않는 범위 내**에서, 뒤에 있는 '의존성 없는 명령어'를 먼저 실행하여 CPU의 유휴 시간을 없앱니다.

### 2) 예시를 통한 이해
1. `M100`에 `1` 저장
2. `M101`에 `2` 저장
3. `M100`과 `M101`을 더해 `M102`에 저장 (**1, 2번에 의존적**)
4. `M150`에 `1` 저장 (**1, 2, 3번과 무관**)

* **순차 처리**: 3번이 끝날 때까지 4번은 대기해야 함.
* **비순차 처리**: 3번이 기다리는 동안 상관없는 **4번을 먼저 실행**하여 효율 증대.

---

## 4. 용어정리 및 결론
* **명령어 파이프라이닝**: 단계를 나눠서 겹쳐 실행하기 (컨베이어 벨트)
* **슈퍼스칼라**: 파이프라인을 여러 개 만들기 (멀티 벨트)
* **비순차적 명령어 처리**: 의존성이 없는 명령어 순서를 바꿔 실행하기 (지능적인 순서 변경)

현대 CPU는 이 모든 기법을 조합하여 클럭 속도 이상의 폭발적인 성능 향상을 이끌어내고 있습니다.