
## 1. 명령어의 구조

명령어는 `연산 코드`와 `오퍼랜드`라는 두 개의 핵심 필드로 구성됩니다.

| 구성 요소 | 의미 | 특징 |
| :--- | :--- | :--- |
| **연산 코드 (Opcode)** | 수행할 연산 | 명령어의 가장 앞부분에 위치 (예: `ADD`, `MOVE`) |
| **오퍼랜드 (Operand)** | 연산의 대상 | 데이터 자체 또는 데이터가 저장된 `위치(주소)` |

### **명령어 필드 보충 설명**
* **주소 필드:** 오퍼랜드 필드에는 실제 값보다 주소가 담기는 경우가 많아 `주소 필드`라고도 부릅니다.
* **오퍼랜드 개수:** `0-주소`부터 `3-주소` 명령어까지 다양하게 존재합니다.

---

## 2. 연산 코드(Opcode)의 4가지 유형

1. **데이터 전송:** 

    - `MOVE` : 데이터를 옮겨라 (주로 레지스터에서 다른 레지스터로 데이터를 옮길때)
    - `STORE` : 메모리에 어떤 값을 또는 어떤 위치에 있는 값을 저장하라
    - `LOAD(FETCH)` : 메모리에서부터 CPU로 데이터를 가져와라 
    - `PUSH` : 각각 스택에 데이터를 저장하라
    - `POP` : 스택의 최상단 데이터를 가져와라

2. **산술/논리 연산:** 

    - `ADD` / `SUBTRACT` / `MULTIPLY` / `DIVIDE` : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
    - `INCREMENT` / `DECREMENT` : 오퍼랜드에 `1`을 더해라 / 오퍼랜드에 `1`을 빼라
    - `AND` / `OR` / `NOT` : 각 논리 연산을 수행하라
    - `COMPARE` : 두 개의 숫자 또는 `TRUE` / `FALSE` 값을 비교하라

3. **제어 흐름 변경:** 

    - `JUMP` : 특정 주소로 실행 순서를 옮겨라
    - `CONDITIONAL JUMP` : 특정 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - `HALT` : 프로그램의 실행을 완전히 멈춰라
    - `CALL` : 되돌아올 주소(return 주소)를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - `RETURN` : `CALL`을 호출할 때 저장했던 주소로 다시 돌아감

4. **입출력 제어:** 

    - `READ(INPUT)` : 특정 입출력 장치로부터 데이터를 읽어라
    - `WRITE(OUTPUT)` : 특정 입출력 장치로 데이터를 써라 
    - `START IO` : 입출력 장치를 시작하라 
    - `TEST IO` : 입출력 장치의 상태를 확인하라

### **중요 자료구조 (스택 vs 큐)**

- **스택 (Stack):** 
    - `LIFO(Last In First Out)` 구조
    - 한쪽끝이 막혀 있는 듯한 자료를 저장하는 저장하는 구조
    - `PUSH`로 데이터를 넣고 `POP`으로 추출. 가장 나중에 저장된게 가장 먼저 나옴

- **큐 (Queue):** 
    - `FIFO(First In First Out)` 구조
    - 양쪽끝이 뚫린 통같은 구조
    - 먼저 들어간 데이터가 먼저 나옴


---

## 3. 주소 지정 방식 (Addressing Modes)

오퍼랜드 필드에 `유효 주소`를 담는 이유는 명령어 한 줄의 크기가 제한되어 있기 때문입니다. 
이를 통해 더 큰 메모리 공간을 활용할 수 있습니다.

* **유효 주소 (Effective Address):** 연산에 사용될 실제 데이터가 저장된 위치.

| 방식 | 설명 | 특징 |
| :--- | :--- | :--- |
| **즉시 주소 지정** | 오퍼랜드에 데이터를 직접 명시 | 가장 빠르지만, 데이터 크기가 `Opcode`만큼 제한됨 |
| **직접 주소 지정** | 오퍼랜드에 유효 주소를 직접 명시 | 구현이 쉽지만, 주소 표현 범위가 제한적임 |
| **간접 주소 지정** | 유효 주소의 `주소`를 명시 | 매우 넓은 주소 범위 표현 가능, 메모리 접근 2회 필요(느림) |
| **레지스터 주소 지정** | 데이터가 저장된 `레지스터` 번호 명시 | 메모리 접근보다 훨씬 빠름 |
| **레지스터 간접 주소 지정**| 주소가 저장된 `레지스터` 번호 명시 | 레지스터의 속도와 간접 지정의 유연함을 동시에 활용 |


---

## 4. 핵심 요약

1. **명령어 구성:** `무엇을(연산 코드)` + `어디를 대상으로(오퍼랜드)`
2. **속도 차이:** CPU 내부의 `레지스터` 접근이 외부 `메모리(RAM)` 접근보다 훨씬 빠름.
3. **주소 지정의 목적:** 명령어 내의 한정된 비트로 **더 넓은 메모리 영역의 데이터를 다루기 위함**.