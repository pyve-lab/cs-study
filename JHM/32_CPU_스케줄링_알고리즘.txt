~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
32강 CPU 스케줄링 알고리즘
~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
스케줄링 알고리즘
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. 선입 선처리 스케줄링
2. 최단 작업 우선 스케줄링
3. 라운드 로빈 스케줄링
4. 최소 잔여 시간 우선 스케줄링
5. 우선순위 스케줄링
6. 다단계 큐 스케줄링
7. 다단계 피드백 큐 스케줄링

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
선입 선처리 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= FCFS (First Come First Served) 스케줄링

 - 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
 - 먼저 CPU를 요청한 프로세스부터 CPU 할당
 - 단점 : 프로세ㅅ들이 기다리는 시간이 매우 길어질 수 있다는 부작용(=호위 효과)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
최단 작업 우선 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= SJF (Shorted Job First) 스케줄링

 - 호위 효과를 방지하려면?
 - CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
 - CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
라운드 로빈 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= RR (Round Robin) 스케줄링

 - 선입 선처리 스케줄링 + 타임 슬라이스 (time slice)
 - 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
 - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
   - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
   - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입 (문맥교환)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
최소 잔여 시간 우선 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= SRT (Shortest Remaining Time) 스케줄링

 - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
 - 최단 작업 우선 스케줄링 : 작업 시간이 짧은 프로세스부터 처리한느 스케줄링 알고리즘
 - 라운드 로빈 스케줄링 : 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
 - 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
우선순위 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 - 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
 - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
 - 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ( 우선순위 스케줄링
 - 우선순위 스케줄링의 근본적인 문제점, 기아(starvation) 현상
 - 우선순위 높은 프로세스만 주구장창 실행
 - 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
 - 이를 방지하기 위한 기법 : 에이징(aging)
 - 오랫동안 대시한 프로세스의 우선순위를 점차 높이는 방식
 - 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
   - 우선순위가 낮아도 언젠가는 우선순위가 높아진다

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
다단계 큐 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= Multilevel queue 스케줄링

 - 우선순위 스케줄링의 발전된 형태
 - 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
   - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
   - 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
다단계 피드백 큐 스케줄링
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
= Multilevel feedback queue 스케줄링

 - 다단계 큐 스케줄링의 발전된 형태
 - 큐 간의 이동이 가능한 다단계 큐 스케줄링
 - 다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동 불가
   - 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
   - 기아 현상 발생 가능
 - 즉, 어떤 프로세스의 CPU 시간이 길면 우선순위가 낮아지ㄱ
   어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식
 - CPU 스케줄링 방식으로 알려져 있음

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
마무리
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4가지 키워드로 정리하는 핵심 포인트
- 저장 장치 계층 구조는 각기 다른 용량과 성능의 저장 장치들을 계층화하여 표현한 구조입니다.
- 캐시 메모리는 CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치입니다.
- 캐시 적중률이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있습니다.
- 캐시 메모리는 참조 지역성의 원리에 따라 데이터를 예측하여 캐시 적중률을 높입니다.

확인문제
1. 다음 보기에 있는 저장 장치들로 저장 장치 계층 구조 도식도를 채우세요.
   보기 메모리, 보조기억장치, 캐시 메모리, 레지스터
   ::::::::: 답 ① 레지스터 ② 캐시 메모리 ③ 메모리 ④ 보조기억장치 :::::::::

2. 캐시 메모리와 관련된 설명 중 옳지 않은 것을 고르세요.
   ① 캐시 메모리는 CPU가 사용할 법한 데이터를 저장합니다.
   ② 캐시 메모리는 참조 지역성의 원리에 입각해 데이터를 가져와 저장합니다.
   ③ 캐시 메모리는 메모리와 CPU 사이에 위치합니다.
   ④ 캐시 적중률이 높으면 캐시 메모리의 성능이 떨어집니다.
   ::::::::: 답 ④ :::::::::