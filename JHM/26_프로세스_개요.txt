~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
26강 프로세스 개요
~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
"실행 중인 프로그램", 프로세스

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스 직접 확인하기
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
윈도우 [작업 관리자]
리눅스, macOS [ps 명령어]

- 포그라운드 프로세스 (foreground process)
  : 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운드 프로세스 (background process)
  : 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스
    데몬(daemon), 서비스(service)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스 제어 블록
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 모든 프로세스는 실행을 위해 CPU가 필요하다
- But, CPU 자원은 한정되어 있다

- 프로세서들은 돌아가며 한정된 시간 만큼만 CPU 이용
  - 자신의 차례에 정해진 시간만큼 CPU 이용
  - 타이머 인터럽트가 발생하면 차례 양보

- 빠르게 번갈아 수행되는 프로세스들을 관리해야
- 이를 위해 사용하는 자료구조가 프로세스 제어 블록 (이하 PCB)
  - 프로세스 관련 정보를 저장하는 자료 구조
  - 마치 상품에 달린 태그와 같은 정보
  - 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기

- PCB에 담기는 대표적인 정보
  - 프로세스 ID (=PID)
    - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호 (학교의 학번, 회사의 사번)
  - 레지스터 값
    - 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 -> 실행 재게
    - 프로그램 카운터, 스택 포인터 ...
  - 프로세스 상태
    - 다음 절(강의)에서 다룰 예정
    - 입출력 장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU 이용 중인 상태 ...
  - CPU 스케줄링 정보
  - 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보 (지금으로서는 '메모리 주소를 알 수 있는 정보가 담기는구나' 정도로)
  - 사용한 파일과 입출력장치 정보
    - 할당된 입출력장치, 사용 중인(열린) 파일 정보

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
문맥 교환 context switch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 한 프로세스에서 다른 프로세스로 실행 순서가 넘어가면?
- 기존에 실행되던 프로세스 A는 지금까지의 중간 정보를 백업
  - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
  - 이러한 중간 정보 == 문맥 (context)
  - 다음 차례가 왔을 때 실행을 재개하기 위한 정보
  - "실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다"
 - 뒤이어 실행할 프로세스 B의 문맥을 복구
   - 자연스럽게 실행 중인 프로세스가 바뀜

 - 이처럼 기존의 실행중인 프로세스 문맥을 백업하고
 - 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을
 - 문맥 교환(context switching) 이라 한다
   - 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리

 - 그렇다면 사용자 영역에는?
   : 운영체제는 커널 영역에 적재된 PCB를 보고 프로세스를 관리합니다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스의 메모리 영역
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 - 크게 코드 영역 (=텍스트 영역), 데이터 영역, 힙 영역, 스택 영역

- 정적할당 영역
 - 코드 영역 (=텍스트 영역)
   - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
   - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역(read-only)

 - 데이터 영역
   - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
   - 전역 변수

- 동적할당 영역
 - 힙 영역
   - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
   - 가비지 컬랙션

 - 스택 영역
   - ㄷ게이터가 일시적으로 저장되는 공간
   - (데이터 영역에 담기는 값과는 달리) 잠깐 쓰다가 말 값들이 저장되는 공간
   - 매개 변수, 지역 변수

- 힙 영역과 스택 영역의 크기는 가변적
  - 일반적으로 힙 영역은 낮은 주소 -> 높은 주소로 할당
  - 일반적으로 스택 영역은 높은 주소 -> 낮은 주소로 할당

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
마무리
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4가지 키워드로 정리하는 핵심 포인트
- 저장 장치 계층 구조는 각기 다른 용량과 성능의 저장 장치들을 계층화하여 표현한 구조입니다.
- 캐시 메모리는 CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치입니다.
- 캐시 적중률이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있습니다.
- 캐시 메모리는 참조 지역성의 원리에 따라 데이터를 예측하여 캐시 적중률을 높입니다.

확인문제
1. 다음 보기에 있는 저장 장치들로 저장 장치 계층 구조 도식도를 채우세요.
   보기 메모리, 보조기억장치, 캐시 메모리, 레지스터
   ::::::::: 답 ① 레지스터 ② 캐시 메모리 ③ 메모리 ④ 보조기억장치 :::::::::

2. 캐시 메모리와 관련된 설명 중 옳지 않은 것을 고르세요.
   ① 캐시 메모리는 CPU가 사용할 법한 데이터를 저장합니다.
   ② 캐시 메모리는 참조 지역성의 원리에 입각해 데이터를 가져와 저장합니다.
   ③ 캐시 메모리는 메모리와 CPU 사이에 위치합니다.
   ④ 캐시 적중률이 높으면 캐시 메모리의 성능이 떨어집니다.
   ::::::::: 답 ④ :::::::::