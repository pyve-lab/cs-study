~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
27강 프로세스 상태와 계층 구조
~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스 상태
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 생성 상태
  - 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
  - 준비가 완료되었다면 준비 상태로

- 준비 상태
  - 당장이라도 CPU를 할당 받아 실행할 수 있지만
  - 자신의 차례가 아니기에 기다리는 상태
  - 자신의 차례가 된다면 실행 상태로 (=디스패치)

- 실행 상태
  - CPU를 할당 받아 실행 중인 상태
  - 할당된 시간 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로
  - 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로

- 대기 상태
  - 프로세스가 실행 도중 입출력장치를 사용하는 경우
  - 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
  - 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로

- 종료 상태
  - 프로세스가 종료된 상태
  - PCB, 프로세스의 메모리 영역 정리

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스 계층 구조
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스 : 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스

- 부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가짐
  일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPID)를 명시하기도
  - 자식 프로세스는 또 다른 자식 프로세스를 낳을 수 있고
  - 그 자식 프로세스는 또 다른 자식 프로세스를 낳을 수 있고
  - 그 자식 프로세스는 또 다른 자식 프로세스를 낳을 수 있고
  - ...
  -> 프로세스의 계층적인 구조 형성

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스 생성 기법
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 부모 프로세스는 자식 프로세스를 어떻게 만들어 내고,
  자식 프로세스는 어떻게 자신만의 코드를 실행할까?

- 복제와 옷 갈아입기
  - 부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성
  - 자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체

- fork 시스템 호출
  - 복사본(=자식 프로세스)생성
  - 부모 프로세스의 자원 상송
  - fork는 자기 자신 프로세스의 복사본을 자식 프로세스로 생성하는 시스템 호출

- exec 시스템 호출
  - 메모리 공간을 새로운 프로그램으로 덮어쓰기
  - 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화
  - exec는 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출입니다.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
프로세스의 메모리 영역
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 - 크게 코드 영역 (=텍스트 영역), 데이터 영역, 힙 영역, 스택 영역

- 정적할당 영역
 - 코드 영역 (=텍스트 영역)
   - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
   - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역(read-only)

 - 데이터 영역
   - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
   - 전역 변수

- 동적할당 영역
 - 힙 영역
   - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
   - 가비지 컬랙션

 - 스택 영역
   - ㄷ게이터가 일시적으로 저장되는 공간
   - (데이터 영역에 담기는 값과는 달리) 잠깐 쓰다가 말 값들이 저장되는 공간
   - 매개 변수, 지역 변수

- 힙 영역과 스택 영역의 크기는 가변적
  - 일반적으로 힙 영역은 낮은 주소 -> 높은 주소로 할당
  - 일반적으로 스택 영역은 높은 주소 -> 낮은 주소로 할당

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
마무리
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4가지 키워드로 정리하는 핵심 포인트
- 저장 장치 계층 구조는 각기 다른 용량과 성능의 저장 장치들을 계층화하여 표현한 구조입니다.
- 캐시 메모리는 CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치입니다.
- 캐시 적중률이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있습니다.
- 캐시 메모리는 참조 지역성의 원리에 따라 데이터를 예측하여 캐시 적중률을 높입니다.

확인문제
1. 다음 보기에 있는 저장 장치들로 저장 장치 계층 구조 도식도를 채우세요.
   보기 메모리, 보조기억장치, 캐시 메모리, 레지스터
   ::::::::: 답 ① 레지스터 ② 캐시 메모리 ③ 메모리 ④ 보조기억장치 :::::::::

2. 캐시 메모리와 관련된 설명 중 옳지 않은 것을 고르세요.
   ① 캐시 메모리는 CPU가 사용할 법한 데이터를 저장합니다.
   ② 캐시 메모리는 참조 지역성의 원리에 입각해 데이터를 가져와 저장합니다.
   ③ 캐시 메모리는 메모리와 CPU 사이에 위치합니다.
   ④ 캐시 적중률이 높으면 캐시 메모리의 성능이 떨어집니다.
   ::::::::: 답 ④ :::::::::