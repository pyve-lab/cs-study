# 🧠 13강 명령어 병렬 처리 기법

> CPU 성능을 높이는 대표적인 방법은  
> 1) **명령어 파이프라인(Instruction Pipeline)** 으로 여러 명령어를 **겹쳐 실행**하고,  
> 2) 파이프라인이 멈추지 않도록 **비순차적 명령어 처리(Out-of-Order)** 로 **합법적인 새치기**를 허용하는 것이다.

---

## 📌 목차
- [🧠 13강 명령어 병렬 처리 기법](#-13강-명령어-병렬-처리-기법)
  - [📌 목차](#-목차)
  - [🚄 명령어 파이프라인](#-명령어-파이프라인)
    - [✅ 파이프라인 단계](#-파이프라인-단계)
    - [✅ 파이프라이닝의 효과](#-파이프라이닝의-효과)
    - [✅ 파이프라인이 없다면](#-파이프라인이-없다면)
  - [⚠️ 파이프라인 위험](#️-파이프라인-위험)
    - [✅ 파이프라인 위험 한눈에 보기](#-파이프라인-위험-한눈에-보기)
    - [✅ 데이터 위험](#-데이터-위험)
    - [✅ 제어 위험](#-제어-위험)
    - [✅ 구조적 위험](#-구조적-위험)
  - [🧩 슈퍼스칼라](#-슈퍼스칼라)
  - [🔀 비순차적 명령어 처리](#-비순차적-명령어-처리)
    - [✅ 개념](#-개념)
    - [✅ 예시로 이해하기](#-예시로-이해하기)
      - [1) 의존성 때문에 스톨이 생기는 흐름](#1-의존성-때문에-스톨이-생기는-흐름)
      - [2) “아무거나” 순서를 바꿀 수는 없다](#2-아무거나-순서를-바꿀-수는-없다)
      - [3) 의존성이 없는 명령어는 순서 교체가 가능](#3-의존성이-없는-명령어는-순서-교체가-가능)
      - [4) 독립 명령어를 먼저 배치해 파이프라인을 계속 굴리기](#4-독립-명령어를-먼저-배치해-파이프라인을-계속-굴리기)
  - [🧾 핵심 요약](#-핵심-요약)

---

## 🚄 명령어 파이프라인

### ✅ 파이프라인 단계
명령어가 처리되는 과정을 **비슷한 시간 간격의 단계(Stage)** 로 나누면,  
각 단계가 서로 충돌하지 않는 한 CPU는 **단계를 동시에 진행**할 수 있다.

![Instruction stages](<images/instruction-pipeline-01.png>)

- **명령어 인출 (Instruction Fetch)**
- **명령어 해석 (Instruction Decode)**
- **명령어 실행 (Execute Instruction)**
- **결과 저장 (Write Back)**

> 위 4단계를 “규칙적인 박자”로 나눠서, 한 단계가 끝나면 다음 단계로 넘기게 만든다.

---

### ✅ 파이프라이닝의 효과
파이프라이닝은 **여러 명령어를 겹쳐 실행**하는 기법이다.

- 같은 단계끼리만 충돌하지 않으면,
  서로 다른 명령어가 **서로 다른 단계**에서 동시에 처리된다.
- 결과적으로, “한 명령어의 전체 지연 시간”이 줄어드는 게 아니라  
  **단위 시간당 처리하는 명령어 수(처리량, throughput)** 가 증가한다.

![Pipeline overlap](<images/instruction-pipeline-02.png>)

> 그림처럼 `명령어1은 실행`, `명령어2는 해석`, `명령어3은 인출`…이 동시에 진행된다.

---

### ✅ 파이프라인이 없다면
파이프라인을 사용하지 않으면 한 명령어를 **끝까지 처리한 다음** 다음 명령어를 실행한다.

![No pipeline](<images/instruction-pipeline-03.png>)

> 위처럼 단계가 겹치지 않아 “대기 구간”이 커지고 전체 시간이 늘어난다.

---

## ⚠️ 파이프라인 위험
파이프라인이 항상 성능을 올려주진 않는다.  
파이프라인이 중간에 멈추거나(스톨), 헛수고가 생겨 비효율이 커지는 상황을 **파이프라인 위험(Hazard)** 이라고 한다.

### ✅ 파이프라인 위험 한눈에 보기
![Pipeline hazards overview](<images/pipeline-hazards.png>)

- **데이터 위험(Data Hazard)**: 명령어 간 의존성(값이 필요함)
- **제어 위험(Control Hazard)**: 분기/점프/인터럽트 등으로 PC(프로그램 카운터) 변경
- **구조적 위험(Structural Hazard)**: 하드웨어 자원(ALU/메모리 포트 등) 경쟁

---

### ✅ 데이터 위험
**명령어 간 의존성** 때문에 발생한다.

- 앞 명령어가 만든 결과를 뒤 명령어가 바로 써야 하는데,
  아직 결과가 준비되지 않으면 파이프라인이 멈추거나 기다려야 한다.

![Data hazard](<images/data-hazard.png>)

> 핵심: “필요한 값이 아직 안 나왔다” → 뒤 명령어는 진행 불가 → 스톨 발생

---

### ✅ 제어 위험
**프로그램 카운터(PC)의 갑작스러운 변화** 때문에 발생한다.

- 점프/분기/콜/인터럽트 같은 명령어는 실행 흐름을 바꾼다.
- CPU가 미리 인출해 둔 명령어들이 “다음에 실행될 명령어”가 아닐 수 있어  
  인출/해석한 작업이 버려지면(Flush) 성능이 떨어진다.

![Control hazard](<images/control-hazard.png>)

> 분기 결과를 늦게 알면, 그동안 미리 해둔 인출이 **헛수고**가 될 수 있다.

---

### ✅ 구조적 위험
서로 다른 명령어가 **동시에 같은 하드웨어 자원**을 쓰려 할 때 발생한다.

- 예: ALU가 하나뿐인데, 두 명령어가 같은 사이클에 ALU를 필요로 함
- 예: 메모리 접근 포트가 하나뿐인데 동시에 메모리에 접근하려 함

> 해결 방향(개념): 자원 추가(멀티 포트, 분리된 유닛 등) 또는 스케줄링으로 충돌 회피

---

## 🧩 슈퍼스칼라
**슈퍼스칼라(Superscalar)** 는 CPU 내부에 **여러 개의 명령어 파이프라인**을 두어  
한 사이클에 **여러 명령어를 동시에 처리**하려는 구조다.

![Superscalar](<images/superscalar.png>)

- 이론상 파이프라인 수가 늘면 처리량도 증가
- 하지만 파이프라인이 많아질수록 위험(데이터/제어/구조적)도 함께 늘어나서  
  **파이프라인 개수만큼 정비례로 빨라지진 않는다.**

---

## 🔀 비순차적 명령어 처리
비순차적 명령어 처리는 파이프라인이 멈추는 상황을 줄이기 위해,  
**명령어를 반드시 작성된 순서대로만 실행하지 않는 기법**이다.

### ✅ 개념
한마디로 **“합법적인 새치기”**.

![Out-of-order overview](<images/out-of-order-execution-overview.png>)

- 의존성 때문에 멈춰야 하는 명령어가 있으면,
- 그동안 놀고 있는 단계에 **먼저 실행해도 되는(의존성 없는) 명령어**를 끼워 넣어
- 파이프라인을 최대한 계속 굴린다.

---

### ✅ 예시로 이해하기

#### 1) 의존성 때문에 스톨이 생기는 흐름
![Out-of-order example 01](<images/out-of-order-example-01.png>)

> 특정 값이 결정되어야 다음 단계로 진행 가능한 상황이 생기면, 그 구간만큼 파이프라인이 비게 된다(스톨).

---

#### 2) “아무거나” 순서를 바꿀 수는 없다
![Out-of-order example 02](<images/out-of-order-example-02.png>)

> 어떤 명령어는 앞 명령어의 결과가 꼭 필요하다. 이런 경우 순서를 바꾸면 결과가 달라질 수 있어 금지.

---

#### 3) 의존성이 없는 명령어는 순서 교체가 가능
![Out-of-order example 03](<images/out-of-order-example-03.png>)
![Out-of-order example 04](<images/out-of-order-example-04.png>)

> 전체 결과/흐름에 영향이 없다면(의존성 없음) 순서를 바꿔도 된다.

---

#### 4) 독립 명령어를 먼저 배치해 파이프라인을 계속 굴리기
![Out-of-order example 05](<images/out-of-order-example-05.png>)

> “마지막에 실행해야 하는 의존성 큰 명령어”는 뒤로 미루고, 먼저 처리 가능한 것부터 실행해 스톨을 최소화한다.

---

## 🧾 핵심 요약
- **파이프라인**: 명령어 실행을 단계로 나누고 **겹쳐 실행**해 처리량 증가
- **파이프라인 위험**
  - 데이터 위험: 결과 의존성 때문에 대기(스톨)
  - 제어 위험: 분기/점프 등으로 미리 인출한 작업이 헛수고
  - 구조적 위험: 하드웨어 자원 충돌
- **슈퍼스칼라**: 파이프라인을 여러 개로 늘려 병렬성을 높이려는 구조(하지만 위험도 증가)
- **비순차 처리**: 의존성 없는 명령어를 **합법적으로 재배치**해 파이프라인 중단을 줄임
