# 31강 CPU 스케줄링 개요

> 운영체제가 여러 프로세스에게 **CPU 자원을 “공정하고 합리적으로” 배분**하는 방법을 정리한다.  
> 핵심 키워드: **우선순위 / 스케줄링 큐 / 선점형 vs 비선점형**

---

## 📚 목차

- [31강 CPU 스케줄링 개요](#31강-cpu-스케줄링-개요)
  - [📚 목차](#-목차)
  - [📌 CPU 스케줄링이란?](#-cpu-스케줄링이란)
    - [프로세스 상태와 스케줄링(큰 흐름)](#프로세스-상태와-스케줄링큰-흐름)
  - [⭐ 프로세스 우선 순위](#-프로세스-우선-순위)
    - [“그냥 돌아가면서 쓰면 공정하지 않나?”](#그냥-돌아가면서-쓰면-공정하지-않나)
    - [우선 순위의 특징](#우선-순위의-특징)
    - [우선 순위 확인 (Linux)](#우선-순위-확인-linux)
  - [🧺 스케줄링 큐](#-스케줄링-큐)
    - [(핵심 그림) 준비 큐 vs 대기 큐](#핵심-그림-준비-큐-vs-대기-큐)
    - [준비 큐](#준비-큐)
    - [대기 큐](#대기-큐)
  - [⏱️ 선점형 vs 비선점형 스케줄링](#️-선점형-vs-비선점형-스케줄링)
    - [선점형 스케줄링(preemptive scheduling)](#선점형-스케줄링preemptive-scheduling)
      - [장점](#장점)
      - [단점](#단점)
    - [비선점형 스케줄링(non-preemptive scheduling)](#비선점형-스케줄링non-preemptive-scheduling)
      - [장점](#장점-1)
      - [단점](#단점-1)
  - [✅ 한눈에 정리](#-한눈에-정리)
    - [오늘의 핵심 체크](#오늘의-핵심-체크)

---

## 📌 CPU 스케줄링이란?

- **CPU 스케줄링(CPU Scheduling)**  
  운영체제가 **프로세스들에게 CPU 시간을 배분**하는 정책/과정
- 목적
  - CPU 자원을 **공정하게** 분배
  - 시스템 전체 **처리량(Throughput)**, **응답 시간(Response Time)** 등을 균형 있게 관리

### 프로세스 상태와 스케줄링(큰 흐름)

프로세스는 실행/대기 등을 반복하며 상태가 바뀌고, 운영체제는 그 흐름 속에서 “다음 CPU를 누가 받을지”를 결정한다.

![](<images/01_process_state_diagram.png>)
> **생성 → 준비 → 실행 → (입출력 요청 시 대기) → (입출력 완료 시 준비) → 종료**  
> 타이머 인터럽트가 발생하면 실행 중이던 프로세스도 다시 준비 상태로 내려올 수 있다.

---

## ⭐ 프로세스 우선 순위

### “그냥 돌아가면서 쓰면 공정하지 않나?”

겉보기엔 “선착순으로 돌아가며 CPU를 쓰면 공정”해 보이지만, 실제로는 프로세스마다 **급한 정도**가 다르다.

- **입출력 집중(I/O-bound) 프로세스**는
  - CPU를 조금 쓰고 → 곧바로 I/O 요청 → **I/O 완료를 기다리는 시간**이 생김
  - I/O가 끝나면 빠르게 다시 CPU를 받아야 전체 흐름이 매끈해짐
- **CPU 집중(CPU-bound) 프로세스**는
  - CPU를 오래 쓰는 구간(연산)이 길어, 상대적으로 “빨리 깨워서 처리해야 할 긴급성”이 낮은 경우가 많음

아래 그림처럼, 프로세스는 보통 **CPU 사용 구간(CPU burst)** 과 **입출력 대기 구간(I/O wait)** 이 번갈아 나타난다.

![](<images/02_process_priority_io_vs_cpu.png>)
> **CPU 사용 구간**과 **입출력 완료까지 대기하는 시간**이 반복된다.  
> I/O-bound 프로세스는 “I/O 끝났는데 CPU를 못 받아서 또 멈추는 상황”이 생기면 체감 성능이 급격히 떨어질 수 있다.

### 우선 순위의 특징

- 프로세스는 **우선 순위(priority)** 를 가진다.
- 우선 순위는 **PCB(Process Control Block)** 에 저장된다.

### 우선 순위 확인 (Linux)

```bash
ps -el
```

---

## 🧺 스케줄링 큐

- **스케줄링 큐(scheduling queue)** 는  
  “어떤 자원을 이용하려는 프로세스들이 줄 서 있는 공간”으로 이해하면 쉽다.
- 운영체제는 프로세스에게 필요한 자원(CPU / 디스크 / 프린터 등)에 따라  
  해당 큐에 넣고(Enqueue), 정책에 따라 꺼내서(Dequeue) 실행시킨다.

![](<images/03_scheduling_queues_overview.png>)
> **CPU를 쓰고 싶은 프로세스 줄**, **하드 디스크를 쓰고 싶은 프로세스 줄**, **프린터를 쓰고 싶은 프로세스 줄**처럼  
> “자원별 대기 줄”이 존재한다고 보면 된다.

> ⚠️ 스케줄링 큐의 “큐”는 꼭 **선입선출(FIFO)** 일 필요는 없다.  
> 같은 큐 안에서도 **우선순위**에 따라 먼저 처리될 수 있다.

---

### (핵심 그림) 준비 큐 vs 대기 큐

아래 그림은 “CPU를 기다리는 줄(준비 큐)”과 “I/O 장치를 기다리는 줄(대기 큐)”을 한 번에 보여준다.

![](<images/04_ready_vs_waiting_queue.png>)
> - **준비 큐**: CPU를 이용하기 위해 기다리는 줄  
> - **대기 큐**: 입출력 장치를 이용하기 위해 기다리는 줄  
> 실행 중인 프로세스는 **입출력 요청**을 하면 대기 큐로 이동하고, **입출력 완료(인터럽트)** 가 오면 다시 준비 큐로 돌아온다.  
> 또한, **타이머 인터럽트(실행 시간 만료)** 가 오면 실행 → 준비로 되돌아갈 수 있다(선점형의 핵심 포인트).

---

### 준비 큐

- **준비 큐(ready queue)**  
  CPU를 할당받아 실행되기를 기다리는 프로세스들이 서는 줄
- 대상
  - **준비 상태(ready state)** 에 있는 프로세스
- 의미
  - “CPU만 받으면 바로 실행 가능한데, 아직 차례가 아니라 대기 중”

---

### 대기 큐

- **대기 큐(waiting queue)**  
  입출력 장치 같은 특정 자원을 기다리는 프로세스들이 서는 줄
- 대상
  - **대기 상태(waiting state)** 에 있는 프로세스
- 의미
  - “지금은 I/O가 필요해서 CPU를 당장 쓸 이유가 없으니 대기 중”
- 특징
  - 장치가 여러 개라면, 장치별로 대기 큐가 나뉠 수 있음(프린터/디스크/CD-ROM 등)

![](<images/05_waiting_queue_examples.png>)
> 프린터/CD-ROM/하드디스크처럼 **장치별 대기 큐**가 존재할 수 있다.  
> 입출력이 완료되면 **인터럽트**로 OS에 알려지고, 해당 프로세스는 **준비 큐로 이동**해 다시 CPU를 기다린다.

---

## ⏱️ 선점형 vs 비선점형 스케줄링

스케줄링을 크게 나누면 다음 두 가지로 분류할 수 있다.

- **선점형(preemptive)**: 필요하면 OS가 **CPU를 빼앗아** 다른 프로세스에게 준다.
- **비선점형(non-preemptive)**: 프로세스가 CPU를 잡으면 **스스로 끝내거나 대기 상태로 가기 전까지** 빼앗지 않는다.

---

### 선점형 스케줄링(preemptive scheduling)

- 동작 개념
  - 각 프로세스가 **정해진 시간(Time Quantum)** 만큼 CPU를 사용
  - 시간이 끝나면 **타이머 인터럽트** 발생
  - 운영체제가 CPU를 회수 → 다음 프로세스에 할당

#### 장점
- 한 프로세스가 CPU를 **독점하기 어려움**
- 여러 프로세스에 **골고루 CPU를 배분**하기 쉬움

#### 단점
- 프로세스가 바뀔 때마다 **문맥 교환(Context Switch)** 발생
- 문맥 교환은 비용(오버헤드)이 들어서 **오버헤드 증가 가능**

---

### 비선점형 스케줄링(non-preemptive scheduling)

- 동작 개념
  - 프로세스가 CPU를 사용하기 시작하면
  - 그 프로세스가 **종료**되거나 **대기 상태로 전환**되기 전까지
  - 다른 프로세스가 중간에 끼어들 수 없다.

#### 장점
- 선점형에 비해 **문맥 교환 오버헤드가 적을 수 있음**

#### 단점
- 한 프로세스가 오래 CPU를 쓰면 다른 프로세스는 **기다리기만** 해야 함
- 결과적으로 **공정한 분배가 어려울 수 있음**

---

## ✅ 한눈에 정리

| 구분 | 선점형(Preemptive) | 비선점형(Non-preemptive) |
|---|---|---|
| CPU 회수 가능? | 가능 (OS가 빼앗음) | 불가 (자발적 반납) |
| 공정성/응답성 | 보통 더 좋음 | 특정 프로세스에 불리할 수 있음 |
| 문맥 교환 | 많아질 수 있음(오버헤드↑) | 상대적으로 적을 수 있음 |
| 핵심 키워드 | 타이머 인터럽트, 타임 퀀텀 | 종료/대기 전환까지 점유 |

---

### 오늘의 핵심 체크

- CPU 스케줄링은 “CPU 시간을 나눠주는 운영체제의 방식”
- **우선순위는 PCB에 저장**
- 스케줄링 큐에는 **준비 큐 / 대기 큐**
- 스케줄링은 크게 **선점형 / 비선점형**
- 선점형은 **공정성↑** 대신 **문맥 교환 오버헤드↑** 가능
- 비선점형은 **오버헤드↓** 대신 **공정성/응답성↓** 가능
