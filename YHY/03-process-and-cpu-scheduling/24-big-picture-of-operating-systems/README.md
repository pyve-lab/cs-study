# 🧠 24강 운영체제의 큰 그림

## 📚 목차

- [🧠 24강 운영체제의 큰 그림](#-24강-운영체제의-큰-그림)
  - [📚 목차](#-목차)
  - [🎯 개요](#-개요)
  - [✅ 커널(Kernel)](#-커널kernel)
    - [🧩 다양한 운영체제](#-다양한-운영체제)
  - [🧵 이중 모드와 시스템 호출](#-이중-모드와-시스템-호출)
    - [왜 자원에 직접 접근하면 안 될까?](#왜-자원에-직접-접근하면-안-될까)
    - [운영체제는 문지기(대행자)](#운영체제는-문지기대행자)
    - [이중 모드(Dual Mode)](#이중-모드dual-mode)
    - [시스템 호출(System Call)](#시스템-호출system-call)
      - [시스템 호출 흐름(이미지 기반 정리)](#시스템-호출-흐름이미지-기반-정리)
  - [🧾 운영체제의 핵심 서비스](#-운영체제의-핵심-서비스)
    - [1) 프로세스 관리](#1-프로세스-관리)
    - [2) 자원 접근 및 할당](#2-자원-접근-및-할당)
    - [3) 파일 시스템 관리](#3-파일-시스템-관리)
  - [📖 부록(참고): 플래그 레지스터와 모드 구분](#-부록참고-플래그-레지스터와-모드-구분)
  - [🔥 한 장 요약](#-한-장-요약)

---

## 🎯 개요

운영체제(OS)는 컴퓨터 자원을 **안전하고 효율적으로 관리**하며,  
프로그램(응용 프로그램)이 **올바르게 실행**될 수 있도록 기본 서비스를 제공하는 **시스템 소프트웨어**다.

![운영체제 개요](<images/01_overview.png>)

- 위 그림처럼, 응용 프로그램은 운영체제를 통해 하드웨어 자원을 사용한다.
- 운영체제는 프로그램이 마음대로 하드웨어를 건드리지 못하게 하면서, 필요한 작업은 대신 처리해준다.

---

## ✅ 커널(Kernel)

커널은 운영체제의 **핵심 기능**을 담당하는 부분이다.

- 운영체제의 “심장”
- 자원(CPU/메모리/저장장치/입출력장치) 관리, 보호, 제어
- 프로그램이 자원을 사용하려고 할 때 **안전하게** 사용할 수 있도록 중간에서 처리

![커널은 운영체제의 핵심](<images/03_kernel.png>)
_커널은 운영체제의 핵심 기능을 담당한다(자동차의 엔진/사람의 심장 같은 역할)._

### 🧩 다양한 운영체제

운영체제는 종류가 다양하지만, 공통적으로 “핵심 기능(커널)”이라는 중심이 존재한다.

![다양한 종류의 운영체제](<images/02_os_types.png>)

> 참고: UI(GUI/CUI)는 운영체제의 구성 요소일 수 있지만, “커널” 그 자체는 아니다.  
> UI는 사용자와 컴퓨터의 **통로** 역할을 하고, 커널은 운영체제의 **핵심 서비스**를 담당한다.

---

## 🧵 이중 모드와 시스템 호출

### 왜 자원에 직접 접근하면 안 될까?

응용 프로그램이 하드웨어 자원에 직접 접근하게 허용하면 위험하다.

- 여러 프로그램이 동시에 같은 자원을 건드리며 **충돌** 가능
- 잘못된 접근으로 **데이터 손상/덮어쓰기** 가능
- 악의적인 프로그램이 **시스템 전체를 망가뜨릴** 수도 있음

![자원에 직접 접근은 위험](<images/04_no_direct_access.png>)
_“내가 먼저!” 하며 CPU/SSD를 직접 건드리면 충돌/덮어쓰기 같은 문제가 발생할 수 있다._

---

### 운영체제는 문지기(대행자)

운영체제는 응용 프로그램이 자원에 접근하려 할 때 **오직 자신을 통해서만** 접근하도록 하여 자원을 보호한다.  
즉, 운영체제는 자원 접근을 **대행**하는 “문지기” 역할을 한다.

![운영체제가 자원 접근을 대행](<images/05_os_resource_gateway.png>)
_응용 프로그램은 자원을 직접 만지지 않고, 운영체제에게 “대신 접근해줘”라고 요청한다._

예를 들어, “하드디스크에 저장”이 필요하다면:

![응용 프로그램이 하드 디스크에 접근할 때](<images/06_app_disk_access_via_os.png>)
_응용 프로그램 → (운영체제의 저장 코드) → 하드디스크처럼, 운영체제가 중간에서 처리한다._

---

### 이중 모드(Dual Mode)

이 보호 장치는 CPU의 실행 모드를 **사용자 모드**와 **커널 모드**로 나누는 방식(이중 모드)으로 구현된다.

- **사용자 모드(User Mode)**
  - 일반 응용 프로그램이 실행되는 모드
  - 커널 영역 코드를 실행할 수 없음
  - 하드웨어 자원에 직접 접근 불가

- **커널 모드(Kernel Mode)**
  - 운영체제(커널)가 실행되는 모드
  - 자원 접근을 포함한 “특권 명령” 실행 가능

> 핵심: 응용 프로그램은 보통 **사용자 모드**에서 실행되고,  
> 운영체제의 도움이 필요한 순간에만 **커널 모드**로 잠깐 올라갔다가 다시 내려온다.

---

### 시스템 호출(System Call)

응용 프로그램이 운영체제 서비스를 이용하려면 **시스템 호출**을 통해 커널 모드로 전환해야 한다.

- 운영체제마다 정해진 시스템 호출 목록이 존재
- 일종의 **소프트웨어 인터럽트**로 이해할 수 있음
- “운영체제에게 공식적으로 요청하는 통로”

![시스템 호출 종류](<images/07_syscall_catalog.png>)
_대표적인 시스템 호출 예: 프로세스 생성(fork), 파일 열기(open), 읽기(read), 쓰기(write) 등_

#### 시스템 호출 흐름(이미지 기반 정리)
시스템 호출이 일어나면 대체로 아래 흐름으로 이해하면 된다.

1) **시스템 호출 발생(사용자 모드 → 커널 모드 전환 요청)**  
2) **커널(운영체제) 코드 실행**  
3) **처리 결과를 가지고 사용자 모드로 복귀**

![시스템 호출 흐름 1](<images/08_syscall_flow_01.png>)
![시스템 호출 흐름 2](<images/09_syscall_flow_02.png>)
![시스템 호출 흐름 3](<images/10_syscall_flow_03.png>)
_그림처럼 “사용자 영역 ↔ 커널 영역”을 오가며 OS 서비스를 제공받는다._

---

## 🧾 운영체제의 핵심 서비스

운영체제가 제공하는 기능은 다양하지만, 이 강의에서는 핵심을 아래 3가지로 묶어 이해한다.

### 1) 프로세스 관리

- **프로세스 = 실행 중인 프로그램**
- 여러 프로세스가 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 매우 빠르게 **번갈아 실행(시분할)** 한다.
- 운영체제는 프로세스의 생성/실행/종료를 관리하고, 필요하면 “누가 CPU를 언제 쓰는지”도 조율한다.

![프로세스와 CPU 실행(시분할 개념)](<images/11_process_mgmt_timesharing.png>)
_메모리에는 여러 프로세스가 존재하고, CPU는 짧은 시간 단위로 번갈아 실행하면서 “동시에 실행되는 것처럼” 보이게 만든다._

또한, 프로세스들은 CPU뿐 아니라 프린터/디스크 같은 다양한 자원을 요구한다.  
운영체제는 이런 요청을 받아 **충돌 없이** 처리되도록 “조율”한다.

![프로세스들의 자원 요청과 OS의 조율](<images/12_process_mgmt_resource_requests.png>)
_여러 프로세스가 서로 다른 자원(프린터, 디스크 등)을 요구할 때, 운영체제가 우선순위/가능 여부를 판단해 안전하게 처리한다._

---

### 2) 자원 접근 및 할당

운영체제는 제한된 자원(CPU/메모리/입출력장치 등)을 여러 프로세스가 공정하고 효율적으로 쓰도록 관리한다.

- **CPU**: CPU 스케줄링(어떤 프로세스를 먼저? 얼마나 오래 실행할까?)
- **메모리**: 페이징/스와핑 등으로 효율적 관리
- **입출력장치(I/O)**: 인터럽트 기반 처리(인터럽트 서비스 루틴 등)

> 이때 “자원에 직접 접근”이 아니라, 운영체제가 **대행/중재**하는 구조가 핵심이다.

---

### 3) 파일 시스템 관리

- 정보를 **파일 단위**로 저장장치에 보관
- 파일을 **폴더(디렉토리)** 로 묶어 관리
- 파일 생성/삭제/읽기/쓰기/권한 같은 규칙을 운영체제가 제공한다.

---

## 📖 부록(참고): 플래그 레지스터와 모드 구분

아래 그림은 CPU가 내부적으로 관리하는 **플래그(상태) 정보**의 예시다.  
일부 아키텍처/설명에서는 **슈퍼바이저 플래그(또는 유사한 비트)** 를 통해 “커널 모드/사용자 모드” 같은 실행 모드 상태를 표현한다고 설명하기도 한다.

> ✅ 중요한 점: “모드를 구분하는 하드웨어적 방법은 존재하지만”,  
> **구체적인 레지스터/비트 이름과 구조는 CPU 아키텍처마다 다를 수 있다.**

![플래그 레지스터 예시](<images/13_flag_register_overview.png>)
_CPU가 유지하는 여러 플래그(상태 비트) 중 일부는 실행 상태/제어와 관련될 수 있다._

![플래그 레지스터 상세 예시](<images/14_flag_register_examples.png>)
_예시 표처럼 ‘슈퍼바이저 플래그’가 1이면 커널 모드, 0이면 사용자 모드처럼 설명되는 경우가 있다(아키텍처별로 차이 있음)._

---

## 🔥 한 장 요약

- **커널**: 운영체제의 핵심(자원 관리/보호/제어)
- 응용 프로그램은 자원에 **직접 접근 불가** → 위험하기 때문
- 운영체제는 자원 접근을 **대행**하는 문지기
- CPU는 **사용자 모드/커널 모드(이중 모드)** 로 보호를 구현
- OS 기능을 쓰려면 **시스템 호출**로 커널 모드에 요청했다가 다시 복귀

---

