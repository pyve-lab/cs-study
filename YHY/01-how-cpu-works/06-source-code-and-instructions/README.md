# 🧠 6강 소스코드와 명령어

컴퓨터는 사람이 작성한 **소스 코드(Source Code)** 를 그대로 이해하지 못한다.  
그래서 우리가 작성한 코드는 결국 컴퓨터가 실행 가능한 형태인 **저급 언어(기계어/어셈블리어)** 로 변환되어 실행된다.

---

## 목차
- [🧠 6강 소스코드와 명령어](#-6강-소스코드와-명령어)
  - [목차](#목차)
  - [고급 언어와 저급 언어](#고급-언어와-저급-언어)
    - [🧩 고급 언어 (High-level Language)](#-고급-언어-high-level-language)
    - [🧱 저급 언어 (Low-level Language)](#-저급-언어-low-level-language)
      - [1) 기계어 (Machine Code)](#1-기계어-machine-code)
      - [2) 어셈블리어 (Assembly Language)](#2-어셈블리어-assembly-language)
  - [컴파일 언어와 인터프리트 언어](#컴파일-언어와-인터프리트-언어)
    - [🛠️ 컴파일 언어 (Compile Language)](#️-컴파일-언어-compile-language)
      - [변환 흐름](#변환-흐름)
      - [특징](#특징)
    - [▶️ 인터프리트 언어 (Interpret Language)](#️-인터프리트-언어-interpret-language)
      - [특징](#특징-1)
    - [📌 비교/차이(이미지로 정리)](#-비교차이이미지로-정리)
    - [🌗 경계는 딱 잘라 나뉘지 않음](#-경계는-딱-잘라-나뉘지-않음)
  - [참고](#참고)

---

## 고급 언어와 저급 언어

### 🧩 고급 언어 (High-level Language)
- 개발자가 이해하기 쉽게 만든 언어
- 예) **C, C++, Python, Java** 등

---

### 🧱 저급 언어 (Low-level Language)
- 컴퓨터가 이해하고 실행하는 언어
- 대표적으로 **기계어**, **어셈블리어**

![Low-level language](<images/low-level-language.png>)
> *저급 언어는 크게 기계어와 어셈블리어로 나뉜다.*

#### 1) 기계어 (Machine Code)
- **0과 1(이진수)** 또는 **16진수**로 이루어진 명령어들의 집합
- CPU가 직접 이해하고 실행하는 형태

#### 2) 어셈블리어 (Assembly Language)
- 기계어(0과 1)를 사람이 읽기 편하도록 기호/단어로 표현한 저급 언어
- 기계어와 다르게 **소스 코드에 직접 명시하면서 개발**하는 경우도 있음

![Machine code vs assembly](<images/machine-code-vs-assembly.png>)
> *같은 의미의 명령이라도, 기계어는 0/1로 표현되고 어셈블리어는 사람이 읽기 쉬운 형태로 표현된다.*

---

## 컴파일 언어와 인터프리트 언어

고급 언어로 작성된 소스 코드는 저급 언어로 변환되어 실행되는데, 대표적인 방식이 **컴파일 방식**과 **인터프리트 방식**이다.

---

### 🛠️ 컴파일 언어 (Compile Language)

고급 언어(소스 코드)를 컴파일러가 변환하여, 저급 언어(목적 코드)를 만든다.

#### 변환 흐름
고급 언어(소스 코드) → (컴파일러) → 저급 언어(목적 코드)

![Compiled language](<images/compiled-language.png>)
> *소스 코드 전체를 한 번에 확인/변환해서 목적 코드를 만든다.*

#### 특징
- 컴파일러가 소스 코드를 **처음부터 끝까지 전부 훑어본 뒤** 목적 코드를 생성한다.
- 한 줄씩 실행하는 방식이 아니라, **전체를 통째로 컴파일**한다.
- 이 과정에서 보통 다음을 확인한다.
  - 오류가 있는지
  - 사용하지 않는 변수가 있는지
  - 최적화할 수 있는지
- **CPU 종류**나 **컴파일러 종류**에 따라 생성되는 목적 코드 형태가 달라질 수 있다.

---

### ▶️ 인터프리트 언어 (Interpret Language)

인터프리터가 소스 코드를 **한 줄씩 읽어가며 실행**한다.

#### 특징
- 소스 코드 전체가 저급 언어로 변환되기를 기다릴 필요가 없다.
- 실행 중에 해석이 진행되므로, 실행 도중 오류가 나면 그 지점에서 멈출 수 있다.

---

### 📌 비교/차이(이미지로 정리)

![Compile vs interpret compare](<images/compile-vs-interpret-compare.png>)
> *컴파일 방식은 “먼저 번역(목적 코드 생성) 후 실행”, 인터프리트 방식은 “실행하면서 한 줄씩 해석”에 가깝다.*

![Compile vs interpret difference](<images/compile-vs-interpret-difference.png>)
> *컴파일 중 오류가 나면 프로그램이 실행되지 않을 수 있고, 인터프리트는 실행하다가 오류 지점에서 멈추는 형태로 이해하면 쉽다.*

---

### 🌗 경계는 딱 잘라 나뉘지 않음
- 세상 모든 언어가 “컴파일 언어 vs 인터프리트 언어”로 **완벽히 양분되지는 않는다.**
- 경계가 애매하거나, **두 방식을 섞어 쓰는 경우도 있다.**

> 결론:  
> “컴파일 방식”과 “인터프리트 방식”은 고급 언어가 저급 언어로 변환되는 **대표적인 방식**으로 이해하면 된다.

---

## 참고
- https://godbolt.org/  
  *(소스 코드가 어떤 형태의 저급 언어로 변환되는지 비교해보기 좋음)*
